# 今天学习内容
- 今天是值班，加上白天看了一会家里的人打牌，预留时间不足，暂时先学习这么多。
- synchronized锁升级
# 学习笔记
## synchronized锁升级
- 我们都知道jvm的同步（synchronized）是基于进入退出monitor对象（管程）来实现的。每个java对象的实例都会有一个monitor对象，monitor对象与java对象一同创建/销毁。monitor是由C++来管理的。
- 当多线程同时访问同一段代码块时，这些线程会被放到一个entryList集合中，处于阻塞状态的线程都会被放置到该list中。接下来当线程获取到对象的monitor对象时，Monitor是依赖操作系统底层mutex lock锁来实现互斥的。线程获取到mutex lock成功其他线程则无法获取。
- 因为monitor对象是依赖底层操作系统来实现互斥的。这就会存在用户态和内核态的切换（操作系统为了安全区分了用户态（我们程序都在用户态执行），和内核态（cpu相关的指令))。
- 在操作系统层面锁的获取和释放如下图所示:

![锁升级的图示.jpg](https://i.loli.net/2020/01/31/xXvBNTFRVEhcGap.jpg)

- 从上图可知获取锁从用户态切换到内核态，释放锁从内核态切换到用户态，了解操作系统相关的基础知识都清楚，这种切换是非常消耗cpu性能的，它需要保存和恢复一些状态数据等。
- 于是JavaSE1.6为了减少获取和释放锁带来的消耗，对同步锁做了升级。

-- 明天继续
